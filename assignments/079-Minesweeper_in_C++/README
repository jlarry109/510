Minesweeper - C++
This assignment repeats another Python assignment, but the source code has been updated for C++ and takes advantage of classes in C++.

If you are not familiar with the game of minesweeper, you might take a minute to read up about it on the internet (https://en.wikipedia.org/wiki/Minesweeper_(video_game), but you don't need much game expertise to do this assignment.

The distribution contains an almost working version of the code, except that you will need to write code for the constructor, desctructor, and two other methods:

Board(int w, int h, int numMines): width{w}, height{h}, totalMines{numMines}
~Board()
int countMines(int x, int y)
bool checkWin()
Constructor

The constructor must allocate memory for a 2-dimensional array (matrix) of Square objects. It then needs to call addRandomMine() an appropriate number of times (i.e., numMines) to "randomly" place mines on the board.

Notes:

You must initialize your board before starting to call addRandomMine().
The mine generation is pseudo-random and will not change if you re-run the program multiple times with the same parameters.
The board should be constructed such that is indexed as board[y][x]
where y is between 0 and the height and x is between 0 and the width.
Destructor

The destructor frees any memory allocated by the constructor.

countMines()

This method takes an (x,y) coordinate. It should count the mines in the 8 squares around that (x,y) coordinate and return that count.
The Square class contains a behavior (a method) in has_mine() that returns true if a square has a mine or false otherwise. Ensure you pay careful attention to the bounds of the board.

checkWin()

Check if the game has been won, which is identified by the situation when no squares are UNKNOWN.

Note: You should NOT change any of the other provided methods!

Once you have these all working, you should have a playable game of minesweeper. Note that there are a few differences in gameplay from the "standard" game:

Select a square by entering its x (column) and y (row) coordinate. The x coordinates are listed across the top and the y are listed down the left side to reduce counting.
The game will automatically figure out the "obvious" squares: both mines and non-mined spaces. It will reveal these to you as soon as it considers them trivial to figure out.
You cannot manually mark a square that you suspect has a mine
Once your code is complete and verified, submit minesweeper.cpp to the Gradescope assignment.
minesweeper_cpp




#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

#define CLICK_KNOWN_MINE -2
#define CLICK_INVALID -1
#define CLICK_CONTINUE 0
#define CLICK_LOSE 1

#define KNOWN_MINE -3
#define HAS_MINE -2
#define UNKNOWN -1

#define IS_MINE(x) ((x) == HAS_MINE || (x) == KNOWN_MINE)

struct _board_t {
  int ** board;
  int width;
  int height;
  int totalMines;
};

typedef struct _board_t board_t;

void addRandomMine(board_t * b) {
  int x;
  int y;
  //we could have a board too small for the number
  //of mines taht we request. try w*h*10 times before
  //we give up
  int limit = b->width * b->height * 10;
  do {
    x = random() % b->width;
    y = random() % b->height;
    assert(limit > 0);
    limit--;
  } while (b->board[y][x] == HAS_MINE);
  b->board[y][x] = HAS_MINE;
}

void malloc_err(void * ptr) {
  if (ptr == NULL) {
    fprintf(stderr, "malloc failed\n");
    exit(EXIT_FAILURE);
  }
}

board_t * makeBoard(int w, int h, int numMines) {
  //WRITE ME!
  board_t * b;
  int x, y;
  b = malloc(sizeof *b);
  malloc_err((void *)b);
  b->board = malloc(h * sizeof b->board[0]);
  malloc_err((void *)b->board);
  b->width = w;
  b->height = h;
  b->totalMines = numMines;
  for (y = 0; y < h; y++) {
    b->board[y] = malloc(w * sizeof b->board[0][0]);
    malloc_err((void *)b->board[y]);
    for (x = 0; x < w; x++) {
      b->board[y][x] = UNKNOWN;
    }
  }
  while (numMines--) {
    addRandomMine(b);
  }
  return b;
}
void printBoard(board_t * b) {
  int found = 0;
  printf("    ");
  for (int x = 0; x < b->width; x++) {
    printf("%d", x / 10);
  }
  printf("\n    ");
  for (int x = 0; x < b->width; x++) {
    printf("%d", x % 10);
  }
  printf("\n----");
  for (int x = 0; x < b->width; x++) {
    printf("-");
  }
  printf("\n");
  for (int y = 0; y < b->height; y++) {
    printf("%2d: ", y % 100);
    for (int x = 0; x < b->width; x++) {
      if (b->board[y][x] == KNOWN_MINE) {
        printf("*");
        found++;
      }
      else if (b->board[y][x] < 0) {
        printf("?");
      }
      else if (b->board[y][x] == 0) {
        printf(" ");
      }
      else {
        printf("%d", b->board[y][x]);
      }
    }
    printf("\n");
  }
  printf("\n----");
  for (int x = 0; x < b->width; x++) {
    printf("-");
  }
  printf("\n");

  printf("    ");
  for (int x = 0; x < b->width; x++) {
    printf("%d", x / 10);
  }
  printf("\n    ");
  for (int x = 0; x < b->width; x++) {
    printf("%d", x % 10);
  }
  printf("\nFound %d of %d mines\n", found, b->totalMines);
}
int countMines(board_t * b, int x, int y) {
  //WRITE ME!
  int ** board;
  int count = 0;
  int xmin, xmax, ymin, ymax;
  int currx, curry;

  board = b->board;
  xmin = xmax = x;
  ymin = ymax = y;
  if (x > 0)
    xmin--;
  if (x < b->width - 1)
    xmax++;
  if (y > 0)
    ymin--;
  if (y < b->height - 1)
    ymax++;

  for (currx = xmin; currx <= xmax; currx++) {
    for (curry = ymin; curry <= ymax; curry++) {
      if (currx == x && curry == y) {
        continue;
      }
      if (IS_MINE(board[curry][currx])) {
        count++;
      }
    }
  }
  return count;
}

int click(board_t * b, int x, int y) {
  if (x < 0 || x >= b->width || y < 0 || y >= b->height) {
    return CLICK_INVALID;
  }
  if (b->board[y][x] == KNOWN_MINE) {
    return CLICK_KNOWN_MINE;
  }
  if (b->board[y][x] == HAS_MINE) {
    return CLICK_LOSE;
  }
  if (b->board[y][x] != UNKNOWN) {
    return CLICK_CONTINUE;
  }

  b->board[y][x] = countMines(b, x, y);
  return CLICK_CONTINUE;
}

int checkWin(board_t * b) {
  //WRITE ME!
  int height = b->height;
  int width = b->width;
  for (int i = 0; i < width; i++) {
    for (int j = 0; j < height; j++) {
      if (b->board[j][i] == UNKNOWN) {
        return 0;
      }
    }
  }
  return 1;
}

void freeBoard(board_t * b) {
  //WRITE ME!
  int height = b->height;

  for (int i = 0; i < height; i++) {
    free(b->board[i]);
  }
  free(b->board);
  free(b);
}

int readInt(char ** linep, size_t * lineszp) {
  if (getline(linep, lineszp, stdin) == -1) {
    fprintf(stderr, "End of file from keyboard reading a number.  Quitting\n");
    exit(EXIT_FAILURE);
  }
  char * endptr = NULL;
  long int x = strtol(*linep, &endptr, 10);
  if (endptr == *linep) {
    fprintf(stderr, "You did not enter any valid number\n");
    printf("Please try again\n");
    return readInt(linep, lineszp);
  }
  if (*endptr != '\n') {
    fprintf(stderr, "Input was not entirely a number (junk at end)\n");
    printf("Please try again\n");
    return readInt(linep, lineszp);
  }
  if (x > INT_MAX) {
    fprintf(stderr, "%ld is too big for an int!\n", x);
    printf("Please try again\n");
    return readInt(linep, lineszp);
  }
  return x;
}

void doReveal(board_t * b, int x, int y, int revealMines) {
  for (int dy = -1; dy <= 1; dy++) {
    for (int dx = -1; dx <= 1; dx++) {
      int nx = x + dx;
      int ny = y + dy;
      if (nx >= 0 && nx < b->width && ny >= 0 && ny < b->height) {
        if (revealMines) {
          assert(b->board[ny][nx] != UNKNOWN);
          if (b->board[ny][nx] == HAS_MINE) {
            b->board[ny][nx] = KNOWN_MINE;
          }
        }
        else {
          assert(b->board[ny][nx] != HAS_MINE);
          if (b->board[ny][nx] == UNKNOWN) {
            b->board[ny][nx] = countMines(b, nx, ny);
          }
        }
      }
    }
  }
}

int maybeReveal(board_t * b, int x, int y) {
  int unknownSquares = 0;
  int knownMines = 0;
  for (int dy = -1; dy <= 1; dy++) {
    for (int dx = -1; dx <= 1; dx++) {
      int nx = x + dx;
      int ny = y + dy;
      if (nx >= 0 && nx < b->width && ny >= 0 && ny < b->height) {
        if (b->board[ny][nx] == UNKNOWN || b->board[ny][nx] == HAS_MINE) {
          unknownSquares++;
        }
        else if (b->board[ny][nx] == KNOWN_MINE) {
          knownMines++;
        }
      }
    }
  }
  assert(knownMines + unknownSquares >= b->board[y][x]);
  assert(knownMines <= b->board[y][x]);
  if (unknownSquares > 0) {
    int revealMines = (knownMines + unknownSquares == b->board[y][x]);
    int allKnown = knownMines == b->board[y][x];
    if (revealMines || allKnown) {
      assert(!revealMines || !allKnown);
      doReveal(b, x, y, revealMines);
      return 1;
    }
  }
  return 0;
}
void determineKnownMines(board_t * b) {
  int foundMore = 0;
  for (int y = 0; y < b->height; y++) {
    for (int x = 0; x < b->width; x++) {
      if (b->board[y][x] >= 0) {
        foundMore = maybeReveal(b, x, y) || foundMore;
      }
    }
  }
  if (foundMore) {
    determineKnownMines(b);
  }
}

void revealMines(board_t * b) {
  for (int y = 0; y < b->height; y++) {
    for (int x = 0; x < b->width; x++) {
      if (b->board[y][x] == HAS_MINE) {
        b->board[y][x] = KNOWN_MINE;
      }
    }
  }
}
int playTurn(board_t * b, char ** linep, size_t * lineszp) {
  printf("Current board:\n");
  printBoard(b);
  printf("x coordinate:\n");
  int x = readInt(linep, lineszp);
  printf("y coordinate:\n");
  int y = readInt(linep, lineszp);
  int result = click(b, x, y);
  determineKnownMines(b);
  if (result == CLICK_LOSE) {
    printf("Oh no! That square had a mine. You lose!\n");
    revealMines(b);
    printBoard(b);
    return 1;
  }
  else if (result == CLICK_INVALID) {
    printf("That is not a valid square, please try again\n");
  }
  else if (result == CLICK_KNOWN_MINE) {
    printf("You already know there is a mine there!\n");
  }
  else if (checkWin(b)) {
    printBoard(b);
    printf("You win!\n");
    return 1;
  }
  return 0;
}

int main(int argc, char ** argv) {
  if (argc != 4) {
    fprintf(stderr, "Usage: minesweeper width height numMines\n");
    return EXIT_FAILURE;
  }
  int width = atoi(argv[1]);
  int height = atoi(argv[2]);
  int numMines = atoi(argv[3]);
  if (width <= 0 || height <= 0 || numMines <= 0) {
    fprintf(stderr, "Width, height, and numMines must all be positive ints\n");
    return EXIT_FAILURE;
  }
  char * line = NULL;
  size_t linesz = 0;

  do {
    board_t * b = makeBoard(width, height, numMines);
    int gameOver = 0;
    while (!gameOver) {
      gameOver = playTurn(b, &line, &linesz);
    }
    freeBoard(b);
    do {
      printf("Do you want to play again?\n");
    } while (getline(&line, &linesz, stdin) == -1);
  } while (line[0] == 'Y' || line[0] == 'y');
  free(line);
  return EXIT_SUCCESS;
}
